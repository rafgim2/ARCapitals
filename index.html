<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <title>AR Capitals Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
      body { margin: 0; overflow: hidden; font-family: sans-serif; }
      /* Overlay del menú inicial */
      #overlay {
        position: absolute; 
        top: 0; left: 0; 
        width: 100%; 
        height: 100%;
        background-color: #fffa9c;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        z-index: 9999;
        padding-top: 100px;
      }
      #overlay a {
        font-size: 14px;
        margin-top: -10px;
        margin-bottom: 20px;
        color: blue;
        text-decoration: none;
      }
      .respuestas-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      .respuestas-container label {
        font-size: 14px;
        color: black;
      }
      .respuestas-container select {
        font-size: 14px;
      }
      /* Imagen responsiva */
      img {
        border-radius: 20px;
        max-width: 15%;
      }
      @media (orientation: portrait) {
        img {
          max-width: 70%;
        }
      }
    </style>
  </head>
  <body>
    <!-- Audios -->
    <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/acierto.wav" preload="auto"></audio>
    <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/error.wav" preload="auto"></audio>
    <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/timer7.mp3" preload="auto"></audio>
    <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/error.wav" preload="auto"></audio>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

      // ============================================================================
      // 1) Array completo de países y capitales (más de 200), SIN omitir nada:
      // ============================================================================
      const countries = [
        { country: "Afganistán", capital: "Kabul" },
        { country: "Albania", capital: "Tirana" },
        { country: "Argelia", capital: "Argel" },
        { country: "Andorra", capital: "Andorra la Vieja" },
        { country: "Angola", capital: "Luanda" },
        { country: "Antigua y Barbuda", capital: "Saint John's" },
        { country: "Argentina", capital: "Buenos Aires" },
        { country: "Armenia", capital: "Ereván" },
        { country: "Australia", capital: "Camberra" },
        { country: "Austria", capital: "Viena" },
        { country: "Azerbaiyán", capital: "Bakú" },
        { country: "Bahamas", capital: "Nasáu" },
        { country: "Baréin", capital: "Manama" },
        { country: "Bangladés", capital: "Daca" },
        { country: "Barbados", capital: "Bridgetown" },
        { country: "Bielorrusia", capital: "Minsk" },
        { country: "Bélgica", capital: "Bruselas" },
        { country: "Belice", capital: "Belmopán" },
        { country: "Benín", capital: "Porto Novo" },
        { country: "Bután", capital: "Thimphu" },
        { country: "Bolivia", capital: "Sucre" },
        { country: "Bosnia y Herzegovina", capital: "Sarajevo" },
        { country: "Botsuana", capital: "Gaborone" },
        { country: "Brasil", capital: "Brasilia" },
        { country: "Brunéi", capital: "Bandar Seri Begawan" },
        { country: "Bulgaria", capital: "Sofía" },
        { country: "Burkina Faso", capital: "Uagadugú" },
        { country: "Burundi", capital: "Gitega" },
        { country: "Cabo Verde", capital: "Praia" },
        { country: "Camboya", capital: "Nom Pen" },
        { country: "Camerún", capital: "Yaundé" },
        { country: "Canadá", capital: "Ottawa" },
        { country: "República Centroafricana", capital: "Bangui" },
        { country: "Chad", capital: "Yamena" },
        { country: "Chile", capital: "Santiago" },
        { country: "China", capital: "Pekín" },
        { country: "Colombia", capital: "Bogotá" },
        { country: "Comoras", capital: "Moroni" },
        { country: "Congo (Brazzaville)", capital: "Brazzaville" },
        { country: "Congo (Kinshasa)", capital: "Kinsasa" },
        { country: "Costa Rica", capital: "San José" },
        { country: "Costa de Marfil", capital: "Yamusukro" },
        { country: "Croacia", capital: "Zagreb" },
        { country: "Cuba", capital: "La Habana" },
        { country: "Chipre", capital: "Nicosia" },
        { country: "República Checa", capital: "Praga" },
        { country: "Dinamarca", capital: "Copenhague" },
        { country: "Yibuti", capital: "Yibuti" },
        { country: "Dominica", capital: "Roseau" },
        { country: "República Dominicana", capital: "Santo Domingo" },
        { country: "Ecuador", capital: "Quito" },
        { country: "Egipto", capital: "El Cairo" },
        { country: "El Salvador", capital: "San Salvador" },
        { country: "Guinea Ecuatorial", capital: "Malabo" },
        { country: "Eritrea", capital: "Asmara" },
        { country: "Estonia", capital: "Tallin" },
        { country: "Esuatini", capital: "Mbabane" },
        { country: "Etiopía", capital: "Adís Abeba" },
        { country: "Fiyi", capital: "Suva" },
        { country: "Finlandia", capital: "Helsinki" },
        { country: "Francia", capital: "París" },
        { country: "Gabón", capital: "Libreville" },
        { country: "Gambia", capital: "Banjul" },
        { country: "Georgia", capital: "Tiflis" },
        { country: "Alemania", capital: "Berlín" },
        { country: "Ghana", capital: "Acra" },
        { country: "Grecia", capital: "Atenas" },
        { country: "Granada", capital: "Saint George's" },
        { country: "Guatemala", capital: "Ciudad de Guatemala" },
        { country: "Guinea", capital: "Conakri" },
        { country: "Guinea-Bisáu", capital: "Bisáu" },
        { country: "Guyana", capital: "Georgetown" },
        { country: "Haití", capital: "Puerto Príncipe" },
        { country: "Honduras", capital: "Tegucigalpa" },
        { country: "Hungría", capital: "Budapest" },
        { country: "Islandia", capital: "Reikiavik" },
        { country: "India", capital: "Nueva Delhi" },
        { country: "Indonesia", capital: "Yakarta" },
        { country: "Irán", capital: "Teherán" },
        { country: "Irak", capital: "Bagdad" },
        { country: "Irlanda", capital: "Dublín" },
        { country: "Israel", capital: "Jerusalén" },
        { country: "Italia", capital: "Roma" },
        { country: "Jamaica", capital: "Kingston" },
        { country: "Japón", capital: "Tokio" },
        { country: "Jordania", capital: "Amán" },
        { country: "Kazajistán", capital: "Astaná" },
        { country: "Kenia", capital: "Nairobi" },
        { country: "Kiribati", capital: "Tarawa" },
        { country: "Corea del Norte", capital: "Pyongyang" },
        { country: "Corea del Sur", capital: "Seúl" },
        { country: "Kosovo", capital: "Pristina" },
        { country: "Kuwait", capital: "Kuwait" },
        { country: "Kirguistán", capital: "Biskek" },
        { country: "Laos", capital: "Vientián" },
        { country: "Letonia", capital: "Riga" },
        { country: "Líbano", capital: "Beirut" },
        { country: "Lesoto", capital: "Maseru" },
        { country: "Liberia", capital: "Monrovia" },
        { country: "Libia", capital: "Trípoli" },
        { country: "Liechtenstein", capital: "Vaduz" },
        { country: "Lituania", capital: "Vilna" },
        { country: "Luxemburgo", capital: "Luxemburgo" },
        { country: "Madagascar", capital: "Antananarivo" },
        { country: "Malaui", capital: "Lilongüe" },
        { country: "Malasia", capital: "Kuala Lumpur" },
        { country: "Maldivas", capital: "Malé" },
        { country: "Malí", capital: "Bamako" },
        { country: "Malta", capital: "La Valeta" },
        { country: "Islas Marshall", capital: "Majuro" },
        { country: "Mauritania", capital: "Nuakchot" },
        { country: "Mauricio", capital: "Port Louis" },
        { country: "México", capital: "Ciudad de México" },
        { country: "Micronesia", capital: "Palikir" },
        { country: "Moldavia", capital: "Chisináu" },
        { country: "Mónaco", capital: "Mónaco" },
        { country: "Mongolia", capital: "Ulán Bator" },
        { country: "Montenegro", capital: "Podgorica" },
        { country: "Marruecos", capital: "Rabat" },
        { country: "Mozambique", capital: "Maputo" },
        { country: "Birmania", capital: "Naipyidó" },
        { country: "Namibia", capital: "Windhoek" },
        { country: "Nauru", capital: "Yaren" },
        { country: "Nepal", capital: "Katmandú" },
        { country: "Países Bajos", capital: "Ámsterdam" },
        { country: "Nueva Zelanda", capital: "Wellington" },
        { country: "Nicaragua", capital: "Managua" },
        { country: "Níger", capital: "Niamey" },
        { country: "Nigeria", capital: "Abuya" },
        { country: "Macedonia del Norte", capital: "Skopie" },
        { country: "Noruega", capital: "Oslo" },
        { country: "Omán", capital: "Mascate" },
        { country: "Pakistán", capital: "Islamabad" },
        { country: "Palaos", capital: "Ngerulmud" },
        { country: "Panamá", capital: "Ciudad de Panamá" },
        { country: "Papúa Nueva Guinea", capital: "Port Moresby" },
        { country: "Paraguay", capital: "Asunción" },
        { country: "Perú", capital: "Lima" },
        { country: "Filipinas", capital: "Manila" },
        { country: "Polonia", capital: "Varsovia" },
        { country: "Portugal", capital: "Lisboa" },
        { country: "Catar", capital: "Doha" },
        { country: "Rumania", capital: "Bucarest" },
        { country: "Rusia", capital: "Moscú" },
        { country: "Ruanda", capital: "Kigali" },
        { country: "San Cristóbal y Nieves", capital: "Basseterre" },
        { country: "San Vicente y las Granadinas", capital: "Kingstown" },
        { country: "Santa Lucía", capital: "Castries" },
        { country: "Samoa", capital: "Apia" },
        { country: "San Marino", capital: "San Marino" },
        { country: "Santo Tomé y Príncipe", capital: "Santo Tomé" },
        { country: "Senegal", capital: "Dakar" },
        { country: "Serbia", capital: "Belgrado" },
        { country: "Seychelles", capital: "Victoria" },
        { country: "Sierra Leona", capital: "Freetown" },
        { country: "Singapur", capital: "Singapur" },
        { country: "Eslovaquia", capital: "Bratislava" },
        { country: "Eslovenia", capital: "Liubliana" },
        { country: "Islas Salomón", capital: "Honiara" },
        { country: "Somalia", capital: "Mogadiscio" },
        { country: "Sudáfrica", capital: "Pretoria" },
        { country: "Sudán del Sur", capital: "Yuba" },
        { country: "Sudán", capital: "Jartum" },
        { country: "Sri Lanka", capital: "Sri Jayawardenapura" },
        { country: "Palestina", capital: "Jerusalén Este" },
        { country: "Estados Unidos", capital: "Washington, D.C." },
        { country: "Uruguay", capital: "Montevideo" },
        { country: "Uzbekistán", capital: "Taskent" },
        { country: "Vanuatu", capital: "Port Vila" },
        { country: "Ciudad del Vaticano", capital: "Ciudad del Vaticano" },
        { country: "Venezuela", capital: "Caracas" },
        { country: "Vietnam", capital: "Hanói" },
        { country: "Yemen", capital: "Saná" },
        { country: "Zambia", capital: "Lusaka" },
        { country: "Zimbabue", capital: "Harare" }
      ];

      // ============================================================================
      // 2) Variables globales
      // ============================================================================
      let camera, scene, renderer;
      let questionMesh = null;
      let answers = [];
      let correctAnswer = "";
      let hasCollided = false;
      let gameOver = false;
      let correctCount = 0;
      let wrongCount = 0;

      let questionText = "";
      let selectedNumAnswers = 4;
      let gameStartTime = 0;
      const gameDuration = 60; // segundos
      const collisionThreshold = 0.2;
      const resolutionFactor = 4;

      let countdownMesh, countdownCanvas, countdownCtx, countdownTexture;
      let scoreMesh, scoreCanvas, scoreCtx, scoreTexture;
      let finalMessageMesh = null, restartButtonMesh = null;

      let beepPlayed = false;
      let gameReady = false;
      let countdownStarted = false;

      // Guardamos posición/dirección iniciales de la cámara
      let initialCameraPos   = new THREE.Vector3();
      let initialCameraDir   = new THREE.Vector3();

      // Sparks
      let sparkTexture = null;
      const sparksSystems = [];

      // ============================================================================
      // 3) Funciones de arranque (init, onWindowResize, etc.)
      // ============================================================================
      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        window.addEventListener('resize', onWindowResize);

        // Overlay inicial
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        overlay.innerHTML = `
          <img src="ARCapitals2.jpeg" alt="ARCapitals" style="margin-bottom:20px;">
          <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
          <div class="respuestas-container">
            <label for="numAnswers">Respuestas:</label>
            <select id="numAnswers">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
        `;

        // ARButton con requiredFeatures (hand-tracking)
        const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test','hand-tracking'] });
        arButton.style.position = 'absolute';
        arButton.style.bottom = '120px';
        arButton.style.left = 'calc(50% - 75px)';
        arButton.style.width = '150px';
        arButton.style.height = '50px';
        arButton.style.fontSize = '16px';
        arButton.style.backgroundColor = 'green';
        arButton.style.color = 'white';

        overlay.appendChild(arButton);
        document.body.appendChild(overlay);

        // Cuando comienza la sesión XR
        renderer.xr.addEventListener('sessionstart', () => {
          // Guardamos la posición y dirección donde estaba la cámara al iniciar
          camera.getWorldPosition(initialCameraPos);
          camera.getWorldDirection(initialCameraDir);
          initialCameraDir.normalize();

          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          createAnswerObjects(selectedNumAnswers);
          overlay.remove();
          generateQuestion(); 
          createScoreDisplay();
          gameReady = true;
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ============================================================================
      // 4) Crear y actualizar los paneles de respuesta
      // ============================================================================
      // Se crea una malla vacía para cada respuesta
      function createAnswerObjects(numAnswers) {
        for (let i = 0; i < numAnswers; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = 256 * resolutionFactor;
          canvas.height = 256 * resolutionFactor;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
          ctx.fillStyle = "#FFFFFF";
          ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText("...", canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
          const geometry = new THREE.PlaneGeometry(0.15, 0.15);
          const mesh = new THREE.Mesh(geometry, material);

          answers.push(mesh);
          scene.add(mesh);
        }
      }

      // Actualizamos el texto y redistribuimos la posición/orientación
      function updateAnswerObjects() {
        const n = selectedNumAnswers;
        // Creamos un set de respuestas falsas + la correcta
        const wrongSet = new Set();
        while (wrongSet.size < (n - 1)) {
          const rnd = Math.floor(Math.random() * countries.length);
          const cand = countries[rnd].capital;
          if (cand !== correctAnswer) {
            wrongSet.add(cand);
          }
        }
        const array = [correctAnswer, ...wrongSet];
        array.sort(() => Math.random() - 0.5);

        // Actualizamos el panel de cada malla
        for (let i = 0; i < n; i++) {
          updateAnswerPanel(answers[i], array[i]);
        }
        // Recolocamos y reorientamos en arco
        updateAnswerPositions();
      }

      // ============================================================================
      // 5) Distribución en arco y orientación
      // ============================================================================
      function updateAnswerPositions() {
        const radius = 0.8;   // distancia al centro del arco
        const gapWorld = 0.05;// hueco “mundial” entre paneles
        const gapAngle = gapWorld / radius;
        const numPanels = answers.length;

        // Centro del arco, a 0.8 m delante de la posición inicial
        const centerPos = new THREE.Vector3().copy(initialCameraPos).addScaledVector(initialCameraDir, 0.8);

        // Calculamos el ángulo que ocupa cada panel según su ancho
        let panelAngles = [];
        answers.forEach(mesh => {
          let w = mesh.userData.panelWidth || mesh.geometry.parameters.width;
          let halfAngle = Math.asin((w / 2) / radius);
          panelAngles.push(2 * halfAngle);
        });

        // Suma del ángulo total
        let totalAngle = panelAngles[0] / 2 + panelAngles[numPanels - 1] / 2;
        for (let i = 0; i < numPanels - 1; i++) {
          totalAngle += (panelAngles[i] / 2) + gapAngle + (panelAngles[i+1] / 2);
        }

        let angles = [];
        let currentAngle = -totalAngle / 2 + panelAngles[0] / 2;
        angles.push(currentAngle);
        for (let i = 1; i < numPanels; i++) {
          currentAngle += (panelAngles[i-1] / 2) + gapAngle + (panelAngles[i] / 2);
          angles.push(currentAngle);
        }

        // Vectores “right” y “forwardHorizontal”
        const up = new THREE.Vector3(0,1,0);
        const right = new THREE.Vector3().crossVectors(up, initialCameraDir).normalize().multiplyScalar(-1);
        const forwardHorizontal = new THREE.Vector3(initialCameraDir.x, 0, initialCameraDir.z).normalize();

        // Asignamos posición y orientamos
        answers.forEach((mesh, i) => {
          const angle = angles[i];
          const offset = new THREE.Vector3();
          offset.addScaledVector(right, Math.sin(angle) * radius);
          offset.addScaledVector(forwardHorizontal, Math.cos(angle) * radius);
          offset.y = 0;

          const finalPos = new THREE.Vector3().copy(centerPos).add(offset);
          mesh.position.copy(finalPos);

          // Miramos hacia la posición inicial del usuario
          mesh.lookAt(initialCameraPos);
        });
      }

      // ============================================================================
      // 6) Panel de pregunta y paneles de respuesta (texto)
      // ============================================================================
      function updateQuestionPanel() {
        const text = questionText;
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        const fontSize = 48 * resolutionFactor;
        tmpCtx.font = 'Bold ' + fontSize + 'px Arial';
        const metrics = tmpCtx.measureText(text);
        const padding = 40 * resolutionFactor;
        const canvasWidth = metrics.width + padding;
        const canvasHeight = 128 * resolutionFactor;

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold ' + fontSize + 'px Arial';
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const scaleX = 0.6 / (512 * resolutionFactor);
        const scaleY = 0.15 / (128 * resolutionFactor);
        const newWidth = canvas.width * scaleX;
        const newHeight = canvas.height * scaleY;

        if (questionMesh) {
          questionMesh.material.map = texture;
          questionMesh.material.needsUpdate = true;
          questionMesh.geometry.dispose();
          questionMesh.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
        } else {
          const geometry = new THREE.PlaneGeometry(newWidth, newHeight);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
          questionMesh = new THREE.Mesh(geometry, material);
          questionMesh.position.set(0, 0.3, -0.8);
          scene.add(questionMesh);
        }
      }

      function updateAnswerPanel(mesh, value) {
        const text = value;
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        const fontSize = 75 * resolutionFactor;
        tmpCtx.font = 'Bold ' + fontSize + 'px Arial';
        const metrics = tmpCtx.measureText(text);
        const padding = 40 * resolutionFactor;
        const canvasWidth = metrics.width + padding;
        const canvasHeight = fontSize + padding;

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold ' + fontSize + 'px Arial';
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const scaleFactor = 0.15 / (256 * resolutionFactor);
        const newWidth = canvas.width * scaleFactor;
        const newHeight = canvas.height * scaleFactor;

        mesh.material.map = texture;
        mesh.material.needsUpdate = true;
        mesh.geometry.dispose();
        mesh.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
        mesh.userData.panelWidth = newWidth;
        mesh.userData.answer = value;
      }

      // ============================================================================
      // 7) Generar preguntas
      // ============================================================================
      function generateQuestion() {
        const rnd = Math.floor(Math.random() * countries.length);
        const item = countries[rnd];
        correctAnswer = item.capital;
        questionText = `¿Cuál es la capital de ${item.country}?`;
        if (questionMesh) scene.remove(questionMesh);
        questionMesh = null;
        updateQuestionPanel();
        updateAnswerObjects();
        beepPlayed = false;
      }

      // ============================================================================
      // 8) Mostrar puntuación (score) y cuenta regresiva
      // ============================================================================
      function createScoreDisplay() {
        scoreCanvas = document.createElement('canvas');
        scoreCanvas.width = 256 * resolutionFactor;
        scoreCanvas.height = 128 * resolutionFactor;
        scoreCtx = scoreCanvas.getContext('2d');
        scoreTexture = new THREE.CanvasTexture(scoreCanvas);
        scoreTexture.minFilter = THREE.LinearFilter;
        scoreTexture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.6, 0.3);
        const material = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
        scoreMesh = new THREE.Mesh(geometry, material);
        scoreMesh.position.set(0, -0.2, -0.82);
        scene.add(scoreMesh);
      }

      function updateScoreDisplay() {
        scoreCtx.clearRect(0, 0, scoreCanvas.width, scoreCanvas.height);
        scoreCtx.fillStyle = "#FFFFFF";
        scoreCtx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        scoreCtx.textAlign = "center";
        scoreCtx.textBaseline = "middle";
        scoreCtx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, scoreCanvas.width / 2, scoreCanvas.height / 2);
        scoreTexture.needsUpdate = true;
      }

      function startCountdown() {
        gameStartTime = performance.now();
        countdownCanvas = document.createElement('canvas');
        countdownCanvas.width = 256 * resolutionFactor;
        countdownCanvas.height = 128 * resolutionFactor;
        countdownCtx = countdownCanvas.getContext('2d');
        countdownTexture = new THREE.CanvasTexture(countdownCanvas);
        countdownTexture.minFilter = THREE.LinearFilter;
        countdownTexture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.6, 0.3);
        const material = new THREE.MeshBasicMaterial({ map: countdownTexture, transparent: true });
        countdownMesh = new THREE.Mesh(geometry, material);
        countdownMesh.position.set(0, 0.50, -0.82);
        scene.add(countdownMesh);
      }

      function updateCountdown() {
        const elapsed = (performance.now() - gameStartTime) / 1000;
        const remaining = Math.max(0, gameDuration - elapsed);
        const seconds = Math.floor(remaining);
        let timeColor = (remaining <= 10) ? "red" : "#FFFFFF";
        countdownCtx.clearRect(0, 0, countdownCanvas.width, countdownCanvas.height);
        countdownCtx.fillStyle = timeColor;
        countdownCtx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
        countdownCtx.textAlign = "center";
        countdownCtx.textBaseline = "middle";
        countdownCtx.fillText(seconds < 10 ? "00:0" + seconds : "00:" + seconds, countdownCanvas.width / 2, countdownCanvas.height / 2);
        countdownTexture.needsUpdate = true;

        if (remaining <= -10 && !beepPlayed) {
          const beepSound = document.getElementById('beepSound');
          beepSound.currentTime = 0;
          beepSound.play().catch(e => {});
          beepPlayed = true;
        }
        return remaining;
      }

      // ============================================================================
      // 9) Efectos de chispas
      // ============================================================================
      function createSparkTexture() {
        const size = 128;
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const ctx = c.getContext('2d');
        const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
        grd.addColorStop(0, 'rgba(255,255,255,1)');
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, size, size);
        const tex = new THREE.CanvasTexture(c);
        tex.minFilter = THREE.LinearFilter;
        return tex;
      }

      function createSparksEffect(pos) {
        if(!sparkTexture) sparkTexture = createSparkTexture();
        const count = 100;
        const positions = new Float32Array(count*3);
        const velocities = [];
        for(let i=0; i<count; i++){
          positions[i*3+0] = pos.x;
          positions[i*3+1] = pos.y;
          positions[i*3+2] = pos.z;
          velocities.push(new THREE.Vector3(
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5
          ));
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.02,
          map: sparkTexture,
          transparent: true,
          opacity: 1.0,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          alphaTest: 0.5,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        sparksSystems.push({
          points,
          velocities,
          startTime: performance.now(),
          lastUpdate: performance.now()
        });
      }

      function updateSparks() {
        const now = performance.now();
        for(let i=sparksSystems.length-1; i>=0; i--){
          const sys = sparksSystems[i];
          const dt = (now - sys.lastUpdate)/1000;
          sys.lastUpdate = now;

          const posArray = sys.points.geometry.attributes.position.array;
          for(let j=0; j<sys.velocities.length; j++){
            posArray[j*3+0] += sys.velocities[j].x * dt;
            posArray[j*3+1] += sys.velocities[j].y * dt;
            posArray[j*3+2] += sys.velocities[j].z * dt;
          }
          sys.points.geometry.attributes.position.needsUpdate = true;

          let life = now - sys.startTime;
          if(life > 1700){
            let fadeTime = life-1700;
            let fadeFactor = Math.max(0,1-(fadeTime/300));
            sys.points.material.opacity = fadeFactor;
          }
          if(life > 2000){
            scene.remove(sys.points);
            sparksSystems.splice(i,1);
          }
        }
      }

      // ============================================================================
      // 10) Lógica principal del juego
      // ============================================================================
      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        renderer.render(scene, camera);

        if (gameReady && !countdownStarted) {
          startCountdown();
          const timerSound = document.getElementById('timerSound');
          timerSound.loop = false;
          timerSound.play().catch(e => {});
          countdownStarted = true;
        }

        if (!gameOver) {
          const remaining = updateCountdown();
          updateScoreDisplay();
          if (remaining <= 0) {
            endGame();
          }
        }

        // Detección de colisiones con mano/cámara
        const session = renderer.xr.getSession();
        let interactionPoints = [];
        if (session) {
          const frame = renderer.xr.getFrame();
          if (frame) {
            for (const inputSource of session.inputSources) {
              if (inputSource.hand) {
                const indexTip = inputSource.hand.get('index-finger-tip');
                if (indexTip) {
                  const jointPose = frame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                  if(jointPose) {
                    interactionPoints.push(new THREE.Vector3(
                      jointPose.transform.position.x,
                      jointPose.transform.position.y,
                      jointPose.transform.position.z
                    ));
                  }
                }
              }
            }
          }
        }
        if(interactionPoints.length === 0){
          // fallback a la cámara
          let camPos = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          interactionPoints.push(camPos);
        }

        // Colisión con paneles de respuesta (o el botón de reinicio si gameOver)
        if(!gameOver) {
          for(let panel of answers){
            const panelPos = new THREE.Vector3();
            panel.getWorldPosition(panelPos);
            for(const pt of interactionPoints) {
              const dist = panelPos.distanceTo(pt);
              if(dist < collisionThreshold && !hasCollided){
                hasCollided=true;
                if(panel.userData.answer === correctAnswer){
                  correctCount++;
                  playSound('successSound');
                  createSparksEffect(panel.position);
                  if(questionMesh) questionMesh.visible=false;
                  answers.forEach(a=>a.visible=false);
                  setTimeout(()=>{
                    if(!gameOver){
                      generateQuestion();
                      if(questionMesh) questionMesh.visible=true;
                      answers.forEach(a=>a.visible=true);
                    }
                    hasCollided=false;
                  },1000);
                } else {
                  wrongCount++;
                  playSound('errorSound');
                  answers.forEach(a=>a.material.color.set(0xff0000));
                  setTimeout(()=>{
                    answers.forEach(a=>a.material.color.set(0xffffff));
                    hasCollided=false;
                  },500);
                }
                break;
              }
            }
          }
        } else {
          // Si el juego terminó, comprobamos el botón "Reiniciar"
          if(restartButtonMesh) {
            const btnPos = new THREE.Vector3();
            restartButtonMesh.getWorldPosition(btnPos);
            for(const pt of interactionPoints){
              const dist = btnPos.distanceTo(pt);
              if(dist < collisionThreshold && !hasCollided){
                hasCollided=true;
                playSound('successSound');
                createSparksEffect(restartButtonMesh.position);
                restartButtonMesh.visible=false;
                setTimeout(()=>{
                  restartGame();
                  hasCollided=false;
                },1000);
                break;
              }
            }
          }
        }

        updateSparks();
      }

      function endGame() {
        gameOver = true;
        if(questionMesh) scene.remove(questionMesh);
        if(countdownMesh) scene.remove(countdownMesh);
        if(scoreMesh) scene.remove(scoreMesh);
        answers.forEach(a=>scene.remove(a));

        // Mensaje final
        const c = document.createElement('canvas');
        c.width = 256*resolutionFactor;
        c.height = 128*resolutionFactor;
        const ctx = c.getContext('2d');
        ctx.fillStyle="#007BFF";
        drawRoundedRect(ctx, 0, 0, c.width, c.height, 10*resolutionFactor);
        ctx.fillStyle="#FFFFFF";
        ctx.font = 'Bold '+(24*resolutionFactor)+'px Arial';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText("Fin del Juego", c.width/2, 30*resolutionFactor);
        ctx.font = 'Bold '+(18*resolutionFactor)+'px Arial';
        ctx.fillText(`Aciertos: ${correctCount}`, c.width/2, 65*resolutionFactor);
        ctx.fillText(`Fallos: ${wrongCount}`, c.width/2, 100*resolutionFactor);

        const tex = new THREE.CanvasTexture(c);
        tex.minFilter = THREE.LinearFilter;
        const geo = new THREE.PlaneGeometry(0.5,0.25);
        const mat = new THREE.MeshBasicMaterial({ map:tex, transparent:true });
        finalMessageMesh = new THREE.Mesh(geo, mat);
        finalMessageMesh.position.set(0, 0, -0.8);
        scene.add(finalMessageMesh);

        // Botón "Reiniciar"
        restartButtonMesh = createButton("Reiniciar");
        restartButtonMesh.position.set(0, -0.3, -0.8);
        scene.add(restartButtonMesh);
      }

      function restartGame() {
        if(finalMessageMesh) scene.remove(finalMessageMesh);
        if(restartButtonMesh) scene.remove(restartButtonMesh);
        if(questionMesh) scene.remove(questionMesh);

        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach(a=>scene.remove(a));
        answers = [];

        createAnswerObjects(selectedNumAnswers);
        generateQuestion();
        countdownStarted=false;
        gameReady=true;
        createScoreDisplay();

        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime=0;
        timerSound.loop=false;
        timerSound.play().catch(e=>{});
      }

      // ============================================================================
      // 11) Botones y audio
      // ============================================================================
      function createButton(text) {
        const c = document.createElement('canvas');
        c.width = 128 * resolutionFactor;
        c.height = 64 * resolutionFactor;
        const ctx = c.getContext('2d');
        ctx.fillStyle="#007BFF";
        drawRoundedRect(ctx, 0, 0, c.width, c.height, 10*resolutionFactor);
        ctx.fillStyle="#FFFFFF";
        ctx.font='Bold '+(18*resolutionFactor)+'px Arial';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText(text, c.width/2, c.height/2);
        const tex=new THREE.CanvasTexture(c);
        tex.minFilter = THREE.LinearFilter;
        const g = new THREE.PlaneGeometry(0.2, 0.1);
        const m = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        return new THREE.Mesh(g,m);
      }

      function playSound(id){
        const el = document.getElementById(id);
        if(el){
          const clone = el.cloneNode();
          clone.play().catch(e=>{});
        }
      }

      // Dibujo de rectángulo redondeado
      function drawRoundedRect(ctx, x, y, w, h, r){
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
        ctx.fill();
      }

      // ============================================================================
      // 12) Desbloqueo de audio en móviles
      // ============================================================================
      window.addEventListener('touchstart', function unlockAudio(){
        const s1 = document.getElementById('successSound');
        const s2 = document.getElementById('errorSound');
        [s1, s2].forEach(a=>{
          a.play().then(()=>{
            a.pause();
            a.currentTime=0;
          }).catch(e=>{});
        });
      }, { once:true });

      // ============================================================================
      // 13) Detección de toques en pantalla (fallback si no hay hand-tracking)
      // ============================================================================
      window.addEventListener('touchstart', function(event){
        if(!/Mobi|Android/i.test(navigator.userAgent)) return; 
        const t = event.touches[0];
        const x = (t.clientX / window.innerWidth) * 2 - 1;
        const y = - (t.clientY / window.innerHeight) * 2 + 1;
        const mouseVector = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, camera);

        let objs = [];
        if(!gameOver) {
          objs = answers;
        } else {
          if(restartButtonMesh) objs = [restartButtonMesh];
        }

        const intersects = raycaster.intersectObjects(objs);
        if(intersects.length > 0 && !hasCollided){
          const panel = intersects[0].object;
          hasCollided = true;
          if(!gameOver){
            if(panel.userData.answer === correctAnswer){
              correctCount++;
              playSound('successSound');
              createSparksEffect(panel.position);
              if(questionMesh) questionMesh.visible=false;
              answers.forEach(a=>a.visible=false);
              setTimeout(()=>{
                if(!gameOver){
                  generateQuestion();
                  if(questionMesh) questionMesh.visible=true;
                  answers.forEach(a=>a.visible=true);
                }
                hasCollided=false;
              },1000);
            } else {
              wrongCount++;
              playSound('errorSound');
              answers.forEach(a=>a.material.color.set(0xff0000));
              setTimeout(()=>{
                answers.forEach(a=>a.material.color.set(0xffffff));
                hasCollided=false;
              },500);
            }
          } else {
            playSound('successSound');
            createSparksEffect(panel.position);
            panel.visible=false;
            setTimeout(()=>{
              restartGame();
              hasCollided=false;
            },1000);
          }
        }
      }, false);

      // ============================================================================
      // Lanzamos la escena AR
      // ============================================================================
      init();
      animate();
    </script>
  </body>
</html>
